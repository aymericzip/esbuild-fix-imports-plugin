import { relative, resolve } from "path";
import { type Plugin } from "esbuild";
import { createRequire } from "module";

// Get the current working directory as the origin absolute path.
const originAbsolutePath = process.cwd();

// Ensure using require function in ES modules.
const isESModule = typeof import.meta.url === "string";
export const requireFunction = isESModule
  ? createRequire(import.meta.url)
  : require;

/**
 * ESBuild plugin to forcefully replace path aliases with relative paths in the output files.
 * It reads the alias configuration from tsconfig.json and modifies the output files to resolve the aliases.
 *
 * @returns {import('esbuild').Plugin} An ESBuild plugin object.
 */
export const fixAliasPlugin = (): Plugin => ({
  name: "fixAliasPlugin",
  setup: (build) => {
    // Resolve the absolute path to the output directory.
    const outDir = build.initialOptions.outdir ?? "dist";
    const outDirAbsolutePath = resolve(originAbsolutePath, outDir);

    // Determine the output file extension based on the build options.
    const outExtension = build.initialOptions.outExtension?.[".js"] ?? ".js";

    // Resolve the path to the tsconfig.json file.
    const tsconfigPath = build.initialOptions.tsconfig ?? "./tsConfig.ts";

    // Import the tsconfig.json file as a JSON module.
    const tsConfig = requireFunction(tsconfigPath);

    // Extract the 'paths' from the tsconfig compilerOptions, or default to an empty object.
    const alias = tsConfig?.compilerOptions?.paths ?? {};

    // Hook into the 'onEnd' event of the build process.
    build.onEnd((result) => {
      // If there are errors, do not proceed.
      if (result.errors.length > 0) {
        return;
      }

      // Iterate over each output file generated by ESBuild.
      for (const outputFile of result.outputFiles ?? []) {
        // Only target files with the specified output extension.
        // This ignores additional files emitted, like sourcemaps (e.g., "*.js.map").
        if (!outputFile.path.endsWith(outExtension)) {
          continue;
        }

        // Calculate the relative path from the output file to the output directory.
        const relativePath = relative(outputFile.path, outDirAbsolutePath);
        // Remove the leading '/' from the relative path.
        const fixedRelativePath = relativePath.slice(1);

        // Get the original file contents.
        const fileContents = outputFile.text;
        // Modify the file contents by replacing aliases with relative paths.
        const nextFileContents = modifyAlias(
          fileContents,
          fixedRelativePath,
          alias
        );

        // Update the output file contents with the modified contents.
        outputFile.contents = Buffer.from(nextFileContents);
      }
    });
  },
});

// Regular expressions to match ESM import statements and CJS require statements.
const ESM_IMPORT_EXP = /from\s+['"]([^'"]+)['"]/g;
const CJS_REQUIRE_EXP = /require\(\s*['"]([^'"]+)['"]\s*\)/g;

/**
 * Modifies the contents of a file by replacing path aliases with relative paths.
 *
 * @param {string} contents - The contents of the file to modify.
 * @param {string} relativePath - The relative path from the file to the output directory.
 * @param {Record<string, string[]>} alias - The alias configuration from tsconfig.json.
 * @returns {string} The modified file contents.
 */
const modifyAlias = (
  contents: string,
  relativePath: string,
  alias: Record<string, string[]>
) => {
  let result = contents;

  // Replace ESM import paths that match aliases with the new relative paths.
  result = result.replace(ESM_IMPORT_EXP, (match, importPath) => {
    const newImportPath = replaceAliasInPath(importPath, relativePath, alias);
    return match.replace(importPath, newImportPath);
  });

  // Replace CJS require paths that match aliases with the new relative paths.
  result = result.replace(CJS_REQUIRE_EXP, (match, importPath) => {
    const newImportPath = replaceAliasInPath(importPath, relativePath, alias);
    return match.replace(importPath, newImportPath);
  });

  return result;
};

/**
 * Replaces an import path if it matches any alias with the corresponding relative path.
 *
 * @param {string} importPath - The original import path from the file.
 * @param {string} relativePath - The relative path from the file to the output directory.
 * @param {Record<string, string[]>} alias - The alias configuration from tsconfig.json.
 * @returns {string} The new import path with aliases replaced by relative paths.
 */
const replaceAliasInPath = (
  importPath: string,
  relativePath: string,
  alias: Record<string, string[]>
) => {
  // Iterate over each alias key in the alias configuration.
  for (const aliasKey in alias) {
    const aliasPatterns = alias[aliasKey]; // Array of alias paths

    // Iterate over each pattern associated with the alias key.
    for (const aliasPattern of aliasPatterns) {
      if (aliasKey.endsWith("*")) {
        // Handle wildcard aliases.
        const aliasKeyBase = aliasKey.slice(0, -1);
        const aliasPatternBase = aliasPattern.slice(0, -1);

        // Check if the import path starts with the alias base.
        if (importPath.startsWith(aliasKeyBase)) {
          const restOfPath = importPath.slice(aliasKeyBase.length);

          // Construct the new relative path.
          const newRelativePath = `${relativePath}/${aliasPatternBase}${restOfPath}`;

          // Clean up the new relative path.
          let cleanedNewRelativePath = newRelativePath
            .replace("/./", "/")
            .replace("./../", "../");

          return cleanedNewRelativePath;
        }
      } else if (importPath === aliasKey) {
        // Construct the new relative path.
        const newRelativePath = `${relativePath}/${aliasPattern}`;

        // Clean up the new relative path.
        let cleanedNewRelativePath = newRelativePath
          .replace("/./", "/")
          .replace("./../", "../");

        return cleanedNewRelativePath;
      }
    }
  }
  // Return the original import path if no alias matches.
  return importPath;
};
